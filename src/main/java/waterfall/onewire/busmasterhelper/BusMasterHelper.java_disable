package waterfall.onewire.busmasterhelper;

import java.util.*;
import java.util.regex.Pattern;

import waterfall.onewire.BusMasterManagerObserver;
import waterfall.onewire.DSAddress;
import waterfall.onewire.busmaster.BusMaster;
import waterfall.onewire.busmaster.SearchBusCmd;

/**
 * Manager is probably a mis-nomer here because it is not actually managing the lifetime of the BMs that it knows about.
 * Really it is a Device Registry Helper. The reason here is that the BMs are instantiated, started and even stopped
 * completely independently from the BusMasterManager. This is particularly true when you consider that we might be
 * talking about a remote BusMaster which is controlled by a different System.
 *
 * So our role here is really coordinate the Searching of the Bus so every Consumer does not have to poll things AND
 * know which BusMasters have which devices.  We are an intermediary as it were.
 *
 * This opens up the question about what exactly a BusMasterManager would actually do? Right now the individual
 * Application is responsible for instantiating and starting the BMs and they never stop. For a remote server one
 * could imagine that a shutdown of one BM could take place and a startup of another and so the Consumers will miss
 * their BM and have to be prepared for another to take over, or the old one to come back.
 *
 * Once a Consumer knows what BM its device is on it seems like it just keeps trying and once it loses the connection
 * it just keeps trying, albehit with a lower poll rate, until a connection is re-established. Even if the BM comes
 * back and the Devie is not found the Consumer still needs to plug away until at some point IT is told to stop OR the
 * DeviceRegistry find the device though a different BM.
 *
 * Note that once a BM is handed to the Registry it keeps plugging away at it, if the BM is stopped then it still
 * will try to talk to it. Only if the original entity which added the BM removes it will we stop. This means of course
 * that whatever Application which decided the BMs exist (like for a HTTP client) needs to be aware of changes to this
 * setup completely outside of the DeviceRegistration.
 *
 * Now, consider something interesting with regard to the actual bus itself. Once a Device is found and the BM is known
 * then the Consumer would like to talk to the BM directly for purposes of Alarms. It is not doing this on the global
 * basis but on the known bus that it is on.
 *
 * So that seems to direct us that the BusMaster API itself should support a TimerTask which would "Push" Alarm polls.
 * If it is doing that..well who is interested in the results and how is that managed? Now we are moved to the idea
 * that the Consumers are really attached to the BusMaster itself.
 *
 * The Consumer would like to know about all the possible BMs since that is something which is potentially configurable.
 * The Consumer it seems is potentially interested in two things for a BM:
 * 1) A poll rate looking for a device...but no longer once the device has been found. That might mean for example that
 * once all the devices are found by the interested Consumers no more polling is required. If that is true then each
 * Consumer should be responsible for communication what poll rate it wants for the general search.
 * 2) Likewise the Alarm search is also something which is Consumer driven. If no Consumers want to know about Alarms
 * then then is no point in driving this at all.
 *
 * How does a Consumer know about BMs? If the BM Manager exists then it shifts to being a passive thing which knows
 * about BMs and the Consumers can look to it for connection? But if that is true then the Consumers need to register
 * with it so that the BM Manager can TELL them about the BMs so they can register with them...if they need to.
 *
 * Can spring help us here to autoregister Objects of a certain interface? Of course if each Consumer is auto-wired
 * and in their constructor they register the implicit interest is in new BusMasters.
 *
 * I feel like we have a simplistic event handling thing here with Consumers being Observers. The Events which
 * are potentially interesting are probably:
 * BusMaster Registered Event
 * BusMaster DeRegistered Event
 * Device Found Event
 * Device Alarm Event
 *
 * A Consumer which wants to discover Devices, both New and Alarm needs to make a separate registration with the
 * BusMaster expressing its unique New and Alarm rate. Once it does not want that rate anymore then it can remove the
 * request. This allows the BM to not waste time doing things that nobody wants.
 *
 * This idea of Long Polling seems quite simple. The HttpBMClient can simply call the remote system via the standard
 * API and ask for the polling rate it needs and then, if any of IT'S Consumers want to be polled, then it calls the
 * remote system and registers a proxy for itself so that some polling occurs. This Proxy (may not be the right term)
 * lives on the target server in the Controller REST api and probably something to do with a unique way to identity
 * the caller. Anyway, with some timeouts the Proxy and automatically de-register itself from the BusMaster and the
 * DeviceRegistration.
 *
 * This would have a nice property in that until the remote system starts up and finds the server AND starts polling
 * will any Search for devices occur. If the remote system dies and the polling request times out then the Search
 * stops (unless there are any local Consumers).
 *
 * I like this. We will need to generate unique keys so that we can identify who is who and when to time things out.
 *
 * The BM is going to have to have its own Timer task to do push Searches. This is convenient since it is reasonable
 * for someone to want to find a specific BM and interact with it rather than some abstract service for Devices. So
 * knowing about the BM and being able to talk to it separate from just talking to a single Device.
 *
 * Anyone of course can query the BM for anything but it is more efficient for multiple users of the Bus to
 * cooperate in at least device and Alarm searches.
 *
 * class BusMasterHelperObserverEvents {
 *
 * }
 *
 * public class EventDevicesSearchChange extends BusMasterHelperObserverEvents
 *
 * public class EventDevicesAlarm extends BusMasterHelperObserverEvents
 *
 * class BusMasterHelperObserver {
 *      void update(BusMasterHelper bmh, BusMasterHelperObserverEvents event);
 * }
 *
 * Observing the BMH is looking to be a nightmare.
 *
 * What if we instead had the Helper coordinate by providing something that COULD be Observed?
 *
 *
 * Maybe this SearchHelper can be something associated with the BusMaster so we could have it be somewhat
 * more intelligent? Since we already have to know the BusMaster to get the right one, why not have it be
 * part of the BusMaster in the beginning? The implementation of the SearchHelper might be quite different
 * for a physical bus vs the http one - the latter just needs to ensure that SOMETHING is happening on the
 * remote system to drive the bus and if nothing special comes up (no changes) then there is no reason to
 * drive a search at all...other than the first time. The http simply needs to register a long request with
 * an Observer on the server side which will drive things appropriately. As long as someone is waiting on
 * the client side then we have to have a proxy waiting on the server side too.
 *
 * So the SearchHelper now becomes an interface. Or maybe it is abstract so we can get the Observable for free.
 *
 *
 * public SearchHelper BusMaster.getSearchHelperFor(BusMaster bm)
 *
 * public abstract class SearchHelper extends Observable {
 *
 * // superclass override methods
 * public void addObserver(this) - uses default min search period
 *
 * public void deleteObserver(this)
 *
 * // extended methods
 * public void addObserver(this, long minSearchPeriodMs) - uses default search period
 *
 * public void minimumSearchPeriodFor(Observer o, long minSearchPeriodMs)
 *
 * public long getDefaultMinSearchPeriodMs();
 *
 * So the physical device implementation is going to create a search command and run it.
 * It will remember the old results and diff the new one and only notify about the changes.
 * This is a specific implementation for search, the Alarm one would not want that behavior.
 * Perhaps the super class can declare a protected method which is savePreviousSearch and
 * the Alarm implementation would do nothing with it, and the getPreviousSearch() would return
 * null all the time. The event to be created to be under the class control too, as long as it is
 * a common baseclass.
 *
 * Now how we handle the timer bit is somewhat complicated. Cleary for the http version we are not
 * going to start a timer, in fact we might actually send some command to our controller on the server
 * to start up a observer proxy on our behalf with a long running read how we get the data back.
 * So we do not actually setup a timer ourselves, we defer that to the server. So timing and callback
 * cannot be intrinsic to the implemenation, unless we make it some choice.
 *
 * Maybe defining some methods which will do the timer and do a callback to the run() method which will
 * call the command to execute and wait for a response...though I suppose we do not want to
 *
 * The common bits appear to be the registration, the rules and calculation about the minimum timer
 * amount and the computation that it needs to be changed. If there are no more observers than the
 * search can stop. How the search is stopped depends on how the search is implemented.
 *
 * Perhaps the http version and cleverly override the search bit. Since we will be returning back
 * or own differences we do not need to store anything for example. And the method is actually a
 * kind of command - go return me the differences() and it can return nothing if it has no differences.
 *
 * The big bit we are re-using is the Observable - we can call notifyAll and pass in the Event.
 * We can cancel the timer if nobody is observing.
 * We can start the timer if someone is observing.
 * //
 *
 * }
 *
 * The http one does seem to have a bit of a problem in that if it misses any of the notification then
 * the differences are relative to a notification which was missed. In effect it is responsible for
 * knowing what its Observers knew and what the change would be for them. Let us imagine that multiple
 * changes took place on the server and the Observer did not see this...so it's notion of delta is
 * problematic. How can it res-synchronize itself? Well, if the version of that client side thinks is X but
 * the server side is not X + 2 then the server can de-register and re-register and thus get the whole
 * list again? Seems like our attempt to save folks time by not having to independently decide what had
 * been changed is somewhat problematic - we cannot always safely compute that.
 *
 * The notification of the whole list is interesting - after all we DO know that. The need to compute
 * the difference is perhaps something that can be done on demand. The Event could do that work if it
 * was primed with the original and new. If nobody asks for the difference and instead (the http)
 * asks for the whole list then we save ourselves some time on the server and the client side does
 * the difference computing themselves.
 *
 * The other way to do it perhaps is for the Server proxy instance to SAVE the list that it knows
 * is on the client (the client can provide some version/key to represent this) and so it can avoid
 * notifying about searches which did not result in any actual changes to that list. That would save
 * the hassle of returning the same list over and over again.
 *
 * Note that because of the generic nature of the SearchHelper we can actually use it for the http without
 * having to worry about optimizations yet - it will just be polling across the wire treating the
 * busmaster as a generic thing.
 *
 * This then seems to take me back to the BusMasterHelper being the BusMasterRegistry and when
 * a BusMaster is added we can notify the Observers so they can decide if they want to be interested
 * in that Bus. Seems much simpler. I cannot imagine why anyone searching for devices would NOT be
 * interested in the bus.
 *
 * public BusMasterSearchHelper BusMasterHelper.getAlarmSearchHelperFor(BusMaster bm)
 *
 *
 * BusMasterHelper extends Observable
 * Here we could notify about the addition and substraction of BusMasters, or even events based on those BusMasters.
 *
 */
public class BusMasterHelper {

    /**
     * This table holds a mapping from a BusMaster to the devices which are known about it.
     */
    private Hashtable<BusMaster, ArrayList<DSAddress>> busMasterToDSAddressAsHex = new Hashtable<BusMaster, ArrayList<DSAddress>>();

    /**
     * This member holds references to the Objects which have requested regular searches on all BusMasters.
     */
    private HashMap<Object, Long> searchPeriodsMs;

    private class BusMasterData {
        public BusMaster bm;

        public ArrayList<DSAddress> searchLastResult;
        public Timer searchTimer;
        public long searchTimerPeriodMs;

        public HashMap<Object, Long> searchAlarmPeriodsMs;
        public Timer searchAlarmTimer;
        public long searchAlarmTimerPeriodMs;

    }

    /*
     * We want the Observers to register with the BusMasterHelper and give us a timer period.
     *
     * BusMasterHelper.addSearchObserver(Observer o, long searchPeriodMs)
     *
     * Internally we want to divide things up so that they run independently. So if nobody is registered for
     * searching then we do no searching. This
     *
     * Technically each BusMaster is completely different and we need our own Cmd instance to drive it and technically
     * we could have two different searchPeriods between then and even only search on one and not the other.
     *
     * This clearly makes sense for Alarm searches - but that is not a general thing and only tied to a specific bus
     * with a device that some Observer is clearly interested in.
     *
     * If we created a class instance which is tied to a rate, and a command to be fired, and a list of folks who are
     * observing then it seems like that is more simple.
     *
     * It seems a little odd for someone who is just trying to find out where a device is to become an Observer to
     * find out that it was already known...but the alternative is that we have to do the search anyway, then return
     * the value, and if they do not like it then they have to request a search and be an observer.
     *
     * So registering as an Observer is actually a short cut as it were.
     *
     * bmm.addSearchObserver(this) // default Period Ms
     *
     * bmm.addSearchObserver(this, periodMs);
     *
     * pubic void notify(Observable o, Object event) {
     *     if (event instanceof Search) {
     *         if (event.hasMyTarget()) {
     *             bmm.deleteObserver(this);
     *         }
     *     }
     * }
     *
     */

    private ArrayList<BusMasterData> bmdList = new ArrayList<BusMasterData>();

    private class mySearchObservable extends Observable implements TimerTask {
        public mySearchObservable() { }

        public void addObserver(Observer o) {
            super.addObserver(o);

            // If we have any BusMasters, we can notify this Observer on its own thread.
            // Seems like we need to synchronize so we do not end up iterating a list which is changing?
            // The caller might turn around and remove themselves as an Observer if what they wanted was found. So we
            // need to be prepared for that.
            ArrayList<EventDevicesSearchChange> eventList = null;
            synchronized (this) {
                for (BusMasterData bmd : bmdList) {
                    if ((bmd.searchLastResult != null) && (bmd.searchLastResult.size() > 0)) {
                        if (eventList == null) {
                            eventList = new ArrayList<>();
                        }
                        eventList.add(new EventDevicesSearchChange(bmd.bm, bmd.searchLastResult, null));
                    }
                }
            }
            if (eventList != null) {
                for (EventDevicesSearchChange event : eventList) {
                    o.update(this, event);
                }
            }

            synchronized (this) {
                if (countObservers() > 0) {
                    // Someone is waiting for a search to happen, we will need to ensure that a default search
                    // rate occurs, even if the Observer has requested a rate on their own.
                }
            }
        }

        public void deleteObserver(Observer o) {
            super.deleteObserver(o);

            synchronized (this) {
                if (this.countObservers() == 1)
            }

        }

        public void run() {

        }

    }

    public BusMasterHelper() { }

    public void addSearchObserver(Observer o, long searchPeriodMs);

    public void addSearchAlarmObserver(Observer o, BusMaster bm, long searchAlarmPeriodMs);


    /**
     * This is an override of the the Observable implementation
     * @param o
     */
    public void addObserver(Observer o) {
        super.addObserver(o);

        // If we have any BusMasters, we can notify this Observer on its own thread.
        // Seems like we need to synchronize so we do not end up iterating a list which is changing?
        // The caller might turn around and remove themselves as an Observer if what they wanted was found. So we
        // need to be prepared for that.
        ArrayList<EventDevicesSearchChange> eventList = null;
        synchronized (this) {
            for (BusMasterData bmd : bmdList) {
                if ((bmd.lastListFromSearch != null) && (bmd.lastListFromSearch.size() > 0)) {
                    if (eventList == null) {
                        eventList = new ArrayList<>();
                    }
                    eventList.add(new EventDevicesSearchChange(bmd.bm, bmd.lastListFromSearch, null));
                }
            }
        }
        if (eventList != null) {
            for (EventDevicesSearchChange event : eventList) {
                o.update(this, event);
            }
        }
    }

    /**
     * This is an override of the the Observable implementation
     * @param o
     */
    public void deleteObserver(Observer o) {
        super.deleteObserver(o);

    }

    /*
     * Private Methods
     */

    private void notifySearchBusCmdFor(BusMasterData bmd, ArrayList<DSAddress> foundList) {

        if (BusMasterHelper.this.notifyObservers();)
    }

    private class SearchBusMasterTimerTask extends TimerTask {
        private BusMasterData bmd;
        private SearchBusCmd searchCmd;

        public SearchBusMasterTimerTask(BusMasterData bmd) {
            this.bmd = bmd;
            this.searchCmd = bmd.bm.querySearchBusCmd(null);
        }

        public void run() {
            searchCmd.execute();

            if (searchCmd.getResult() == ) { }

            // if the result are good then we can sort the list and diff it against the last list.

            // we should call the baseclass private method with the update list. We have the BMD so that is easy to pass.
            // Let this outer method to compute the diff set and call the Observers of the BusMasterHelper.
            BusMasterHelper.this.notifySearchBusCmdFor(bmd, searchCmd.getResultList());

        }

    }

    /**
     * An instance of this Class will be passed to all registered Observers for every executed SearchCmd which results
     * in the discovery of a new Device or the lost of an existing Device since the last SearchCmd executed.
     */
    public class EventDevicesSearchChange {
        protected BusMaster bm;
        protected List<DSAddress> dsAddrFound;
        protected List<DSAddress> dsAddrLost;

        /**
         *
         * @param dsAddrFound List of Devices found since the last Search. May not be null.
         * @param dsAddrLost List of Devices lost since the last Search. May not be null.
         */
        public EventDevicesSearchChange(BusMaster bm, List<DSAddress> dsAddrFound, List<DSAddress> dsAddrLost) {
            this.bm = bm;
            this.dsAddrFound = dsAddrFound;
            this.dsAddrLost = dsAddrLost;
        }

    }

    /**
     * An instance of this Class will be passed to all registered Observers for every executed SearchAlarmCmd which
     * results in the discovery of a Device reporting Alarm status.
     */
    public class EventDevicesAlarm {
        protected BusMaster bm;
        protected List<DSAddress> dsAddrList;

        public EventDevicesAlarm(BusMaster bm, List<DSAddress> dsAddrList) {
            this.bm = bm;
            this.dsAddrList = dsAddrList;
        }
    }

    /**
     * Add a BusMaster to be managed by the BusMasterManager.
     * @param bm
     */
    public void add(BusMaster bm) {
        assert (bm != null);

        if (busMasterToDSAddressAsHex.containsKey(bm)) {
            System.err.println("Duplicate add of busMaster:" + bm.getName() + " ignored");
            return;
        }

        for (BusMaster t_bm: busMasterToDSAddressAsHex.keySet()) {
            if (t_bm.getName().equals(bm.getName())) {
                System.err.println("Duplicate add of busMaster:" + bm.getName() + " ignored");
                return;
            }
        }

        busMasterToDSAddressAsHex.put(bm, new ArrayList<String>());
    }

    /**
     * The owner of the BusMasterManager is responsible for driving the SearchInterval.
     * It is considered bad form for individual device consumers to keep poking the
     * These intervals are based on the wall clock with the interval being measured
     * from the top of the hour.
     *
     * This method will set the search for new devices interval.
     * @param interval
     */
    public synchronized void setAutoSearchInterval(SearchInterval interval) {

    }

    /**
     * Register the callback for a matching DS address. If the observer has allready been registered than a re-
     * registration may trigger
     * @param observer
     * @param dsAddrPattern
     */
    public void addObserver(BusMasterManagerObserver observer, Pattern dsAddrPattern) {
        ObserverUpdateData found = null;

        for (ObserverUpdateData data : observerList) {
            if (data.getObserver() == observer) {
                found = data;
                break;
            }
        }

        boolean needUpdate = false;

        if (found == null) {
            found = new ObserverUpdateData(observer, dsAddrPattern);
            observerList.add(found);
            needUpdate = true;
        }
        else if (!dsAddrPattern.pattern().equals(found.dsAddrPattern.pattern())) {
            found.updateDSAddrPattern(dsAddrPattern);
            needUpdate = true;
        }

        if (needUpdate) {
            for (BusMaster bm : busMasterToDSAddressAsHex.keySet()) {
                List<String> dsAddressList = busMasterToDSAddressAsHex.get(bm);
                found.update(observer, bm, dsAddressList);
            }
        }
    }


    private void searchAllBusMasters() { };

    /**
     * The search thread. This will be responsible for polling the known busmasters.
     */


    private class SearchTimerTask extends TimerTask {
        public SearchTimerTask() { }

        public void run() {
            searchAllBusMasters();
        }
    }

    public void run() {
        for (;;) {
            if (searchInterval == SearchInterval.Interval_None) {
                // We have nothing to do, stop.
                return;
            }

            // have we waiting long enough?
            if ()



            try {
                Thread.sleep( );
            }
            case (InterruptedException e) {

            }
        }
    }

    /**
     * To simplify the API for Search Observers which wish to watch for changes to the found Devices on the bus this
     * method allows the caller to arrange for the BusMaster to internally generate a SearchCmd at an interval and
     * trigger the standard notification behavior when the found Devices change.
     *
     * Set a Search interval on behalf of the specified Object.
     *
     * The shortest periodInMs value for all the registered Objects will be used.
     *
     * @param obj
     * @param periodInMs Must be greater than zero, or will throw an Exception.
     */
    public void setDeviceSearchIntervalFor(Object obj, long periodInMs) throws IllegalArgumentException {

    }

    /**
     * Clears a previously registered Search interval on behalf of the specified Object.
     * The new Search interval will be changed to reflect the shortest period for all the registered Objects.
     * If no other Object has registered a Search interval then the internal SearchCmd push will halt.
     * @param obj
     */
    public void clearDeviceSearchIntervalFor(Object obj);

    /**
     * To simplify the API for Search Observers which wish to watch for Devices in Alarm state on the bus this method
     * allows the caller to arrange for the BusMaster to internally generate a SearchAlarmCmd at an interval and
     * trigger the standard notification behavior when the found Devices change.
     *
     * Set a Alarm Search interval on behalf of the specified Object.
     *
     * The shortest periodInMs value for all the registered Objects will be used.
     *
     * @param obj
     * @param periodInMs Must be greater than zero, or will throw an Exception.
     */
    public void setDeviceAlarmSearchIntervalFor(Object obj, long periodInMs) throws IllegalArgumentException {

    }

    /**
     * Clears a previously registered Alarm Search interval on behalf of the specified Object.
     * The new Alarm Search interval will be changed to reflect the shortest period for all the registered Objects.
     * If no other Object has registered a Alarm Search interval then the internal SearchBusCmd by Alarm push will halt.
     * @param obj
     */
    public void clearDeviceAlarmSearchIntervalFor(Object obj) {

    }

    /*
    public void updateAfterSearch(SearchBusCmd cmd) {
        if (cmd.getResult() == SearchBusCmd.Result.success) {
            if (cmd.isByFamilyCode()) {
                // nothing to do here, we do not update on that.
            } else if (cmd.isByAlarm()) {
                // we will notify observers about this result.
            } else {
                ArrayList<String> t = busMasterToDSAddressAsHex.get(cmd.getBusMaster());
                if (t == null) {
                    System.err.println("updateAfterSearch() unknown busMaster:" + cmd.getBusMaster().getName() + " ignored");
                    return;
                }
                Collections.sort(t);
                Collections.sort(cmd.getResultList());

                Iterator<String> current = t.iterator();
                Iterator<String> new = cmd.getResultList().iterator();

                if ()


                if (devAddressesAsHex != null) {
                    boolean newdevice = false;

                    for (String addrAsHex : devAddressesAsHex) {
                        BusMaster currBM = devices.get(addrAsHex);
                        if (currBM == null) {
                            devices.put(addrAsHex, bm);
                            newdevice = false;
                        }
                        if (currBM != bm) {
                        }
                    }
                }
            }
        }
    }

    public void addDevicesByAlarm(BusMaster bm, List<String> devicesAsHex) {

    }

    public String[] getDevices() {
        String[] list = new String[devices.size()];

        int i = 0;
        for (Enumeration<String> devEnum = devices.keys(); devEnum.hasMoreElements(); ) {
            list[i++] = devEnum.nextElement();
        }

        return list;
    }

    public BusMaster getBusMasterForDevice(String addrAsHex) {
        return devices.get(addrAsHex);
    }
    */

}
